# Учебный план: RAG Telegram-бот с LangChain

Этот урок рассчитан на студентов, которые прошли первую практику с простым GigaChat ботом. Теперь мы шаг за шагом собираем более сложный проект. В каждой секции указан файл с постфиксом `_empty`, где нужно дописать код. После завершения шага можно свериться с «боевой» версией без постфикса.

Все учебные файлы лежат отдельно в каталоге `training/`, чтобы не мешать готовому решению. Структура зеркальна основной: `training/src/`, `training/scripts/`.

> Советы: сохраняйте прогресс после каждого этапа и запускайте скрипты по мере готовности — так быстрее найти ошибки.

## Шаг 0. Подготовка окружения
1. Скачайте проект: `git clone <repo-url>` или загрузите архив с репозитория и распакуйте.
2. Создайте виртуальное окружение и установите зависимости `pip install -r requirements.txt`.
3. Скопируйте `.env.example` в `.env` и укажите реальные токены.
4. Проверьте структуру папок: `src/`, `scripts/`, `data/`, `storage/`.

## Шаг 1. Разбираемся с конфигурацией (`training/src/config_empty.py`)
- Реализуйте функцию `_comma_separated_set` (подсказка: `split(',')`, `int()` и `set`).
- Заполните поля `Settings` значениями из `os.environ`. Для путей используйте `Path` и метод `os.getenv` с дефолтами.
- Убедитесь, что создаётся объект `settings = Settings()` без ошибок.

## Шаг 2. Настраиваем RAG сервис (`training/src/rag_service_empty.py`)
1. **Эмбеддинги:** в `embeddings` создайте `GigaChatEmbeddings` с кредами из настроек.
2. **Retriever:** загрузите FAISS индекс из `settings.vector_store_path` и верните `store.as_retriever(search_kwargs={"k": settings.top_k_results})`.
3. **LLM:** создайте `GigaChat` с моделью и температурой 0.1.
4. **Промпт:** заполните `ANSWER_PROMPT` текстом с инструкциями ассистенту. Пример в боевой версии.
5. **Цепочка:** вместо `...` подставьте `self.llm` и реализуйте функцию `_invoke` (получить вопрос, поиск, объединить тексты через `"\n\n---\n\n".join`, вызвать `answer_chain`). Верните словарь с ключами `answer` и `source_documents`.

## Шаг 3. Реализуем Telegram-бота (`training/src/bot_empty.py`)
- Добавьте обработчики `/help` и текстовых сообщений (`F.text`).
- В `handle_start` напишите приветствие и проверку прав (см. `settings.allowed_user_ids`).
- В `handle_answer`:
  1. Получите текст вопроса.
  2. Вызовите `self.rag_service.ask(question)`.
  3. Сохраните `history` и сформируйте сообщение-ответ. Если есть `source_documents`, перечислите их.

## Шаг 4. Точка входа (`training/src/main_empty.py`)
- Напишите `main()` так, чтобы он вызывал `asyncio.run(run_bot())` и корректно завершался по `KeyboardInterrupt`.
- Проверьте запуском `python -m training.src.main_empty` (после завершения следующих шагов).

## Шаг 5. Скрипты подготовки данных
1. `training/scripts/fetch_faq_empty.py` — реализуйте `download` (HTTP GET + запись в файл) и добавьте аргументы парсера (`--url`, `--out`, `--no-verify`).
2. `training/scripts/prepare_faq_dataset_empty.py` — пропишите аргументы CLI и функции `parse_html`, `parse_markdown`. Можно повторить логику из готовой версии: BeautifulSoup, поиск заголовков `h2` или `##`.
3. `training/scripts/build_index_empty.py` — прочитайте JSON (список `{question, answer}`), создайте `Document`, нарежьте текст `RecursiveCharacterTextSplitter`, посчитайте эмбеддинги и сохраните FAISS индекс.

## Шаг 6. Создаём файлы с нуля
- Подготовьте собственный `data/faq_my_project.md` или HTML-файл с Q/A. Проще всего запросить у ChatGPT/Гигачат: «скачай FAQ с такого-то сайта и верни в markdown с заголовками `## Вопрос` + текстом ответа».
- С помощью готовых скриптов преобразуйте файл в `data/faq_dataset.json` и соберите индекс `storage/faiss_index`. Скрипты должны быть уже реализованы студентом.

## Шаг 7. Тестирование
1. Запустите `python -m training.scripts.fetch_faq_empty ...` и убедитесь, что файл скачан.
2. Подготовьте датасет и индекс.
3. Запустите `python -m training.src.main_empty` и задавайте вопросы боту в Telegram. Если всё работает, можно смело переходить на «боевые» файлы без постфикса.

## Шаг 8. Работа с Git
Чтобы отправить решение в отдельной ветке:
1. Клонируйте репозиторий (если ещё нет) `git clone <repo-url>` и перейдите в него.
2. Создайте ветку под практику `git checkout -b feature/rag-training`.
3. Добавьте изменённые учебные файлы: `git add training docs/rag_lesson_plan.md`.
4. Сделайте коммит `git commit -m "Выполнил учебную практику RAG"`.
5. Запушьте ветку `git push origin feature/rag-training`.
6. Создайте Pull Request и отправьте ссылку наставнику. В PR опишите, что реализовано, и приложите скриншоты/логи при необходимости.

Удачи! Когда учебные файлы заработают, можно выполнить код-ревью и отрефакторить проект под свой стиль.
